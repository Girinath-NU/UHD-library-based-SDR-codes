<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>USRP C++ Tone Transmitter ‚Äì Explanation</title>

<style>
    body {
        font-family: Arial, Helvetica, sans-serif;
        line-height: 1.6;
        margin: 40px;
        background: #f9f9f9;
        color: #222;
    }
    h1, h2, h3 {
        color: #003366;
    }
    h1 {
        border-bottom: 3px solid #003366;
        padding-bottom: 10px;
    }
    h2 {
        border-bottom: 2px solid #ccc;
        padding-bottom: 6px;
        margin-top: 40px;
    }
    pre {
        background: #1e1e1e;
        color: #dcdcdc;
        padding: 15px;
        overflow-x: auto;
        border-radius: 6px;
    }
    code {
        font-family: Consolas, monospace;
        font-size: 14px;
    }
    table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 15px;
        margin-bottom: 20px;
    }
    th, td {
        border: 1px solid #aaa;
        padding: 10px;
        text-align: left;
    }
    th {
        background: #003366;
        color: white;
    }
    .note {
        background: #e6f2ff;
        border-left: 6px solid #003366;
        padding: 12px;
        margin: 15px 0;
    }
</style>
</head>

<body>

<h1>üì° USRP C++ Tone Transmitter ‚Äì Code Explanation</h1>

<p>
This program uses <b>UHD (USRP Hardware Driver)</b> to transmit a
<b>10 kHz baseband sinusoidal tone</b> at an
<b>RF center frequency of 100 MHz</b>.
</p>

<hr>

<h2>1Ô∏è‚É£ Header Files</h2>

<pre><code>#include &lt;uhd/usrp/multi_usrp.hpp&gt;</code></pre>
<p>Core UHD header used to discover and control the USRP hardware.</p>

<pre><code>#include &lt;uhd/stream.hpp&gt;</code></pre>
<p>Required for streaming IQ samples to the USRP.</p>

<pre><code>#include &lt;complex&gt;</code></pre>
<p>Provides complex numbers used for IQ (I + jQ) samples.</p>

<pre><code>#include &lt;vector&gt;</code></pre>
<p>Used to store IQ samples in a dynamic buffer.</p>

<pre><code>#include &lt;iostream&gt;</code></pre>
<p>Used for console output.</p>

<pre><code>#include &lt;cmath&gt;</code></pre>
<p>Provides mathematical functions such as <code>sin()</code>, <code>cos()</code>, and <code>M_PI</code>.</p>

<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;</code></pre>
<p>Used for timing and delays (optional but useful).</p>

<hr>

<h2>2Ô∏è‚É£ Main Function</h2>

<pre><code>int main()
{
</code></pre>

<p>
Execution of the program starts from the <code>main()</code> function.
</p>

<hr>

<h2>3Ô∏è‚É£ Create USRP Device</h2>

<pre><code>auto usrp = uhd::usrp::multi_usrp::make(uhd::device_addr_t());</code></pre>

<ul>
    <li>Searches for the first connected USRP</li>
    <li>Creates a shared pointer to the USRP object</li>
    <li>Establishes communication between PC and hardware</li>
</ul>

<div class="note">
<b>Concept:</b> This is equivalent to ‚Äúconnecting‚Äù your C++ program to the USRP.
</div>

<hr>

<h2>4Ô∏è‚É£ Transmitter Configuration</h2>

<pre><code>double tx_rate = 200e3;   // 200 kS/s
double tx_freq = 100e6;   // 100 MHz
double tx_gain = 40;      // dB</code></pre>

<table>
<tr><th>Parameter</th><th>Description</th></tr>
<tr><td>tx_rate</td><td>Sample rate (samples per second)</td></tr>
<tr><td>tx_freq</td><td>RF center frequency</td></tr>
<tr><td>tx_gain</td><td>Transmit amplifier gain</td></tr>
</table>

<pre><code>usrp-&gt;set_tx_rate(tx_rate);
usrp-&gt;set_tx_freq(tx_freq);
usrp-&gt;set_tx_gain(tx_gain);</code></pre>

<p>
These functions apply the configuration to the USRP hardware.
</p>

<hr>

<h2>5Ô∏è‚É£ TX Stream Setup</h2>

<pre><code>uhd::stream_args_t stream_args("fc32");
auto tx_stream = usrp-&gt;get_tx_stream(stream_args);</code></pre>

<p>
Creates a transmit stream using <b>32-bit floating-point complex samples</b>.
</p>

<div class="note">
<b>fc32</b> = floating-point, complex, 32-bit
</div>

<hr>

<h2>6Ô∏è‚É£ TX Metadata</h2>

<pre><code>uhd::tx_metadata_t md;
md.start_of_burst = true;
md.end_of_burst   = false;</code></pre>

<p>
Metadata controls when transmission starts and stops.
</p>

<hr>

<h2>7Ô∏è‚É£ Tone Generation</h2>

<pre><code>const size_t buffer_size = 1024;
std::vector&lt;std::complex&lt;float&gt;&gt; buffer(buffer_size);</code></pre>

<p>
Each buffer contains 1024 IQ samples.
</p>

<pre><code>double tone_freq = 10e3; // 10 kHz
double phase = 0.0;
double phase_inc = 2 * M_PI * tone_freq / tx_rate;</code></pre>

<p>
Phase increment determines the tone frequency.
</p>

<div class="note">
<b>Signal equation:</b><br>
x[n] = e<sup>j(2œÄfn/Fs)</sup>
</div>

<hr>

<h2>8Ô∏è‚É£ Transmit Loop</h2>

<pre><code>for (int n = 0; n &lt; 2000; n++)</code></pre>

<p>
Controls how long the signal is transmitted.
</p>

<pre><code>buffer[i] = std::complex&lt;float&gt;(cos(phase), sin(phase));
phase += phase_inc;</code></pre>

<p>
Generates a clean complex sinusoid:
</p>

<ul>
    <li><b>cos()</b> ‚Üí In-phase (I)</li>
    <li><b>sin()</b> ‚Üí Quadrature (Q)</li>
</ul>

<pre><code>tx_stream-&gt;send(buffer.data(), buffer.size(), md);
md.start_of_burst = false;</code></pre>

<hr>

<h2>9Ô∏è‚É£ End of Transmission</h2>

<pre><code>md.end_of_burst = true;
tx_stream-&gt;send("", 0, md);</code></pre>

<p>
Stops transmission cleanly.
</p>

<hr>

<h2>üîü Program Exit</h2>

<pre><code>std::cout &lt;&lt; "Transmission done" &lt;&lt; std::endl;
return 0;</code></pre>

<hr>

<h2>üì° Final RF Output</h2>

<table>
<tr><th>Parameter</th><th>Value</th></tr>
<tr><td>Baseband tone</td><td>10 kHz</td></tr>
<tr><td>RF center frequency</td><td>100 MHz</td></tr>
<tr><td>Sample rate</td><td>200 kS/s</td></tr>
<tr><td>Signal type</td><td>Complex IQ sinusoid</td></tr>
<tr><td>Observed RF</td><td>100.010 MHz</td></tr>
</table>

<div class="note">
‚úî You generated a baseband signal<br>
‚úî Upconverted it using the USRP<br>
‚úî Transmitted a clean RF tone
</div>

</body>
</html>
